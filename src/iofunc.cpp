/*
Comp Eng 3DY4 (Computer Systems Integration Project)

Department of Electrical and Computer Engineering
McMaster University
Ontario, Canada
*/

#include "dy4.h"
#include "iofunc.h"
#include <cstdint>

// some basic functions for printing information from vectors
// or to read from/write to binary files in 32-bit float format
void printRealVector(const std::vector<float> &x)
{
	std::cerr << "Printing float vector of size " << x.size() << "\n";
	for (int i = 0; i < (int)x.size(); i++)
		std::cerr << x[i] << " ";
	std::cerr << "\n";
}

void printRealVector(const std::vector<int> &x)
{
	std::cerr << "Printing float vector of size " << x.size() << "\n";
	for (int i = 0; i < (int)x.size(); i++)
		std::cerr << x[i] << " ";
	std::cerr << "\n";
}

void printComplexVector(const std::vector<std::complex<float>> &X)
{
	std::cerr << "Printing complex vector of size " << X.size() << "\n";
	for (int i = 0; i < (int)X.size(); i++)
		std::cerr << X[i] << " ";
	std::cerr << "\n";
}

// assumes data in the raw binary file is in 32-bit float format
void readBinData(const std::string in_fname, std::vector<float> &bin_data)
{
	std::cerr << "Using file " << in_fname << " (for lab 3 generated by ../model/fmMonoBlock.py)\n";
	std::ifstream fdin(in_fname, std::ios::binary);
	if(!fdin) {
		std::cerr << "File " << in_fname << " not found ... exiting!\n";
		exit(1);
	} else {
		std::cerr << "Reading raw binary from \"" << in_fname << "\"\n";
	}
	fdin.seekg(0, std::ios::end);
	const unsigned int num_samples = fdin.tellg() / sizeof(float);

	bin_data.resize(num_samples);
	fdin.seekg(0, std::ios::beg);
	fdin.read(reinterpret_cast<char*>(&bin_data[0]), num_samples*sizeof(float));
	fdin.close();
}

void readIQData(const std::string in_fname, std::vector<float> &i_data, std::vector<float> &q_data) {
	std::vector<uint8_t> bin_data;
	std::cerr << "Using file " << in_fname << " (for lab 3 generated by ../model/fmMonoBlock.py)\n";
	std::ifstream fdin(in_fname, std::ios::binary);
	if(!fdin) {
		std::cerr << "File " << in_fname << " not found ... exiting!\n";
		exit(1);
	} else {
		std::cerr << "Reading raw binary from \"" << in_fname << "\"\n";
	}
	fdin.seekg(0, std::ios::end);
	const unsigned int num_samples = fdin.tellg() / (sizeof(uint8_t)*2);

	bin_data.resize(num_samples * 2);
	fdin.seekg(0, std::ios::beg);
	fdin.read(reinterpret_cast<char*>(&bin_data[0]), num_samples*2*sizeof(uint8_t));
	fdin.close();
	i_data.resize(num_samples);
	q_data.resize(num_samples);
	for (unsigned int n = 0; n < num_samples; n += 1) {
		i_data[n] = (((float)bin_data[n*2]) - 128.0) / 128.0;
		q_data[n] = (((float)bin_data[n*2 +1]) - 128.0) / 128.0;
	}
}

// assumes data in the raw binary file is 32-bit float format
void writeBinData(const std::string out_fname, const std::vector<float> &bin_data)
{
	std::cerr << "Writing raw binary to \"" << out_fname << "\"\n";
	std::ofstream fdout(out_fname, std::ios::binary);
	for (int i=0; i<(int)bin_data.size(); i++) {
		fdout.write(reinterpret_cast<const char*>(&bin_data[i]),\
								sizeof(bin_data[i]));
	}
	fdout.close();
}

// from project overview document
void readStdinBlockData(unsigned int num_samples, unsigned int block_id, std::vector<float> &block_data) {
	std::vector<char> raw_data(num_samples);
	std::cin.read(reinterpret_cast<char*>(&raw_data[0]), num_samples*sizeof(char));
	for (int k = 0; k < (int)num_samples; k++) {
		// normalize data to float32 +/- 1
		block_data[k] = float(((unsigned char)raw_data[k] - 128) / 128.0);
	}
}

// adapted from project overview document
void writeStdoutBlockData(std::vector<float> &block_data) {
	std::vector<short int> audio_data(block_data.size());
	for (unsigned int k = 0; k < block_data.size(); k++) {
		if (std::isnan(block_data[k])) {
			audio_data[k] = 0;
		} else {
			audio_data[k] = static_cast<short int>(block_data[k] * 16384);
		}
	}
	fwrite(&audio_data[0], sizeof(short int), audio_data.size(), stdout);
}

void interleave(std::vector<float> &out, std::vector<float> &a, std::vector<float> &b) {
	out.clear(); out.resize(a.size() + b.size());
	for (unsigned int i = 0; i < a.size(); i++) {
		out[i * 2]		= a[i];
		out[i * 2 + 1]	= b[i];
	}
}

void deinterleave(std::vector<float> &in, std::vector<float> &a, std::vector<float> &b) {
	a.clear(); b.clear(); a.resize(in.size() / 2); b.resize(in.size() / 2);
	for (unsigned int i = 0; i < a.size(); i++) {
		a[i] = in[i * 2];
		b[i] = in[i * 2 + 1];
	}
}
